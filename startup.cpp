/*
Copyright (C) 1998 BJ Eirich (aka vecna)
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

// startup.c
// Copyright (C) 1998 BJ Eirich

#include <time.h>
#include <stdarg.h> // va_*
#include <stdlib.h>
#include <SDL.h>
#include <SDL_syswm.h>

#include "verge.h"
#include "font.h"
#include "misc.h"
#include "videofilter.h"

#ifdef WIN32
#   include <windows.h>
#endif

// in VERGE.CPP
int VMain();

// Data

static unsigned char vergepal[]=
{
    // Regexp and python rule.  I had the two crank out this whole thing in about 2 mins
    0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0c, 0x0c, 0x0c, 0x14, 0x14, 0x14, 0x1c, 0x1c, 0x1c, 0x24, 0x24,
    0x24, 0x28, 0x28, 0x28, 0x30, 0x30, 0x30, 0x38, 0x38, 0x38, 0x3c, 0x3c, 0x3c, 0x44, 0x44, 0x44, 0x4c,
    0x4c, 0x4c, 0x54, 0x54, 0x54, 0x58, 0x58, 0x58, 0x60, 0x60, 0x60, 0x68, 0x68, 0x68, 0x70, 0x70, 0x70,
    0x74, 0x74, 0x74, 0x7c, 0x7c, 0x7c, 0x84, 0x84, 0x84, 0x88, 0x88, 0x88, 0x90, 0x90, 0x90, 0x98, 0x98,
    0x98, 0xa0, 0xa0, 0xa0, 0xa4, 0xa4, 0xa4, 0xac, 0xac, 0xac, 0xb8, 0xb8, 0xb8, 0xc4, 0xc4, 0xc4, 0xd0,
    0xd0, 0xd0, 0xd8, 0xd8, 0xd8, 0xe4, 0xe4, 0xe4, 0xf0, 0xf0, 0xf0, 0xfc, 0x00, 0x00, 0xec, 0x00, 0x00,
    0xe0, 0x00, 0x00, 0xd4, 0x00, 0x00, 0xc8, 0x00, 0x00, 0xbc, 0x00, 0x00, 0xb0, 0x00, 0x00, 0xa4, 0x00,
    0x00, 0x98, 0x00, 0x00, 0x88, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64, 0x00, 0x00, 0x58,
    0x00, 0x00, 0x4c, 0x00, 0x00, 0x40, 0x00, 0x00, 0xfc, 0xd8, 0xd8, 0xfc, 0xb8, 0xb8, 0xfc, 0x9c, 0x9c,
    0xfc, 0x7c, 0x7c, 0xfc, 0x5c, 0x5c, 0xfc, 0x40, 0x40, 0xfc, 0x20, 0x20, 0xfc, 0x00, 0x00, 0x44, 0x2c,
    0x18, 0x4c, 0x34, 0x1c, 0x54, 0x3c, 0x24, 0x5c, 0x44, 0x28, 0x60, 0x4c, 0x2c, 0x68, 0x54, 0x30, 0x70,
    0x5c, 0x38, 0x78, 0x64, 0x3c, 0xfc, 0xfc, 0xd8, 0xfc, 0xfc, 0xb8, 0xfc, 0xfc, 0x9c, 0xfc, 0xfc, 0x7c,
    0xfc, 0xf8, 0x5c, 0xfc, 0xf4, 0x40, 0xfc, 0xf4, 0x20, 0xfc, 0xf4, 0x00, 0xe4, 0xd8, 0x00, 0xcc, 0xc4,
    0x00, 0xb4, 0xac, 0x00, 0x9c, 0x9c, 0x00, 0x84, 0x84, 0x00, 0x70, 0x6c, 0x00, 0x58, 0x54, 0x00, 0x40,
    0x40, 0x00, 0xd0, 0xfc, 0x5c, 0xc4, 0xfc, 0x40, 0xb4, 0xfc, 0x20, 0xa0, 0xfc, 0x00, 0x90, 0xe4, 0x00,
    0x80, 0xcc, 0x00, 0x74, 0xb4, 0x00, 0x60, 0x9c, 0x00, 0xd8, 0xfc, 0xd8, 0xb8, 0xf4, 0xb8, 0x9c, 0xec,
    0x9c, 0x7c, 0xe4, 0x7c, 0x5c, 0xd8, 0x5c, 0x3c, 0xd0, 0x3c, 0x20, 0xc8, 0x20, 0x00, 0xc0, 0x00, 0x00,
    0xb4, 0x00, 0x00, 0xac, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x98, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x84, 0x00,
    0x00, 0x78, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x50, 0x00, 0x00, 0x48,
    0x00, 0x00, 0x3c, 0x00, 0x08, 0x34, 0x08, 0x0c, 0x28, 0x0c, 0x14, 0x20, 0x14, 0xd8, 0xfc, 0xfc, 0xb8,
    0xfc, 0xfc, 0x9c, 0xfc, 0xfc, 0x7c, 0xfc, 0xfc, 0x5c, 0xfc, 0xfc, 0x3c, 0xfc, 0xfc, 0x20, 0xfc, 0xfc,
    0x00, 0xfc, 0xfc, 0x00, 0xe4, 0xe4, 0x00, 0xcc, 0xcc, 0x00, 0xb4, 0xb4, 0x00, 0x9c, 0x9c, 0x00, 0x88,
    0x88, 0x00, 0x70, 0x70, 0x00, 0x58, 0x58, 0x00, 0x40, 0x40, 0x5c, 0xbc, 0xfc, 0x40, 0xb0, 0xfc, 0x20,
    0xa8, 0xfc, 0x00, 0x9c, 0xfc, 0x00, 0x8c, 0xe4, 0x00, 0x7c, 0xcc, 0x00, 0x6c, 0xb4, 0x00, 0x5c, 0x9c,
    0xd8, 0xd8, 0xfc, 0xb8, 0xbc, 0xfc, 0x9c, 0x9c, 0xfc, 0x7c, 0x80, 0xfc, 0x5c, 0x60, 0xfc, 0x40, 0x40,
    0xfc, 0x20, 0x24, 0xfc, 0x00, 0x04, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xec, 0x00, 0x00, 0xe0, 0x00,
    0x00, 0xd4, 0x00, 0x00, 0xc8, 0x00, 0x00, 0xbc, 0x00, 0x00, 0xb0, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x98,
    0x00, 0x00, 0x88, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x70, 0x00, 0x00, 0x64, 0x00, 0x00, 0x58, 0x00, 0x00,
    0x4c, 0x00, 0x00, 0x40, 0x34, 0x20, 0x00, 0x3c, 0x24, 0x00, 0x48, 0x28, 0x00, 0x50, 0x2c, 0x00, 0x58,
    0x30, 0x00, 0x64, 0x34, 0x00, 0x6c, 0x38, 0x00, 0x78, 0x3c, 0x00, 0x80, 0x40, 0x00, 0x88, 0x44, 0x00,
    0x94, 0x48, 0x00, 0xa0, 0x54, 0x0c, 0xb0, 0x60, 0x18, 0xbc, 0x6c, 0x24, 0xc8, 0x78, 0x30, 0xd4, 0x84,
    0x38, 0xe4, 0x90, 0x44, 0xf0, 0x9c, 0x50, 0xfc, 0xa8, 0x5c, 0xfc, 0xb8, 0x70, 0xfc, 0xc4, 0x88, 0xfc,
    0xd4, 0x9c, 0xfc, 0xe0, 0xb0, 0x88, 0x70, 0x48, 0x94, 0x7c, 0x50, 0xa4, 0x88, 0x5c, 0xb0, 0x94, 0x64,
    0xbc, 0xa0, 0x70, 0xc8, 0xa8, 0x78, 0xd8, 0xb4, 0x80, 0xe4, 0xc0, 0x8c, 0xf0, 0xcc, 0x94, 0xfc, 0xe8,
    0xdc, 0xfc, 0xe0, 0xd0, 0xfc, 0xd8, 0xc4, 0xfc, 0xd4, 0xbc, 0xfc, 0xcc, 0xb0, 0xfc, 0xc4, 0xa4, 0xfc,
    0xbc, 0x9c, 0xfc, 0xb8, 0x90, 0xfc, 0xb0, 0x80, 0xfc, 0xa4, 0x70, 0xfc, 0x9c, 0x60, 0xf0, 0x94, 0x5c,
    0xe8, 0x8c, 0x58, 0xdc, 0x88, 0x54, 0xd0, 0x80, 0x50, 0xc8, 0x7c, 0x4c, 0xbc, 0x78, 0x48, 0xb4, 0x70,
    0x44, 0xa8, 0x68, 0x40, 0xa0, 0x64, 0x3c, 0x9c, 0x60, 0x38, 0x90, 0x5c, 0x34, 0x88, 0x58, 0x30, 0x80,
    0x50, 0x2c, 0x74, 0x4c, 0x28, 0x6c, 0x48, 0x24, 0x5c, 0x40, 0x20, 0x54, 0x3c, 0x1c, 0x48, 0x38, 0x18,
    0x40, 0x30, 0x18, 0x38, 0x2c, 0x14, 0x28, 0x20, 0x0c, 0xfc, 0x00, 0x00, 0xfc, 0x10, 0x00, 0xfc, 0x20,
    0x00, 0xfc, 0x34, 0x00, 0xfc, 0x44, 0x00, 0xfc, 0x54, 0x00, 0xfc, 0x64, 0x00, 0xfc, 0x74, 0x00, 0xfc,
    0x88, 0x00, 0xfc, 0x98, 0x00, 0xfc, 0xa8, 0x00, 0xfc, 0xb8, 0x00, 0xfc, 0xc8, 0x00, 0xfc, 0xdc, 0x00,
    0xfc, 0xec, 0x00, 0xfc, 0xfc, 0x00, 0xfc, 0xbc, 0x00, 0xd8, 0xa0, 0x00, 0xb4, 0x88, 0x00, 0x90, 0x6c,
    0x00, 0x6c, 0x50, 0x00, 0x48, 0x34, 0x00, 0x24, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x00, 0xa0, 0x8c,
    0x00, 0xac, 0x74, 0x00, 0xbc, 0x5c, 0x00, 0xc8, 0x48, 0x00, 0xd4, 0x30, 0x00, 0xe0, 0x18, 0x00, 0xf0,
    0xfc, 0xfc, 0xfc, 0xfc
};

namespace
{
    struct Config
    {
        int xres;
        int yres;
        bool hicolour;
        bool window;

        bool joy;
        int joyIndex;
        int joyX;
        int joyY;
        int jb1, jb2, jb3, jb4;

        VideoFilter* filter;

        Config()
            : xres(320), yres(240)
            , hicolour(false), window(false)
            , joy(false)
            , joyIndex(0)
            , joyX(0), joyY(1)
            , jb1(0) , jb2(1), jb3(2), jb4(3)
            , filter(0)
        {}
    };
}

Config config;

std::string	startmap;   // start map

// ================================= Code ====================================

extern bool vcprofile;
extern void DumpProfile();

void Sys_Error(const char* format, ...)
{
    va_list argptr;
    static char string[1024];
    
    va_start(argptr, format);
    vsprintf(string, format, argptr);
    va_end(argptr);
    
    // <aen> why can't I nest another va() in here?
    Log::Writen("Sys: Exiting with message: ");
    Log::Write(string);
    
    ShutdownTimer();
    input.ShutDown();
    gfx.ShutDown();
    ShutdownSound();

    SDL_Quit();

    printf("%s", string);
    fflush(stdout);
    
    FreeAllMemory();

    DumpProfile();
    
    Log::Write("Exit!");
    exit(string[0] == 0 ? 1 : 0);
}

void InitializeDefaults()
{
    memset(bindarray, 0, sizeof(bindarray)); // clear this here so we don't trigger random events on the first keypress
}

// zero error correcting or detection; fix <aen, apr 21>
void ParseStartupFiles()
{
    VFILE* file = vopen("user.cfg");
    if (!file)
        return;

    std::vector<std::string> lin;
    char c[1024];

    int size = filesize(file);
    
    while (vtell(file) < size)
    {
        vgets(c, 1023, file);

        lin = splitString(c);
        lin[0] = lowerCase(lin[0]); // case insensitive

             if (lin[0] == "mount")         MountVFile(lin[1].c_str());    // mounts a pack file; up to 3? (perhaps gaurd against more?)
        else if (lin[0] == "vidmode")                                      // set video resolution
        {
            config.xres = atoi(lin[1].c_str());
            config.yres = atoi(lin[2].c_str());
        }
        else if (lin[0] == "log")           Log::Enable();                 // log to VERGE.LOG
        else if (lin[0] == "startmap")      startmap = lin[1];             // map VERGE.EXE will run first when executed
        else if (lin[0] == "hicolor")       config.hicolour = true;
        else if (lin[0] == "window")        config.window = true;
        else if (lin[0] == "filter")
        {
            std::string filter = lowerCase(lin[1]);
                 if (filter == "normal")    config.filter = 0;
            else if (filter == "2xsai")     config.filter = new Filter2xSaI();
            else if (filter == "eagle")     config.filter = new FilterEagle();
            else if (filter == "hq2x")      config.filter = new FilterHq2x();
            else if (filter == "hq3x")      config.filter = new FilterHq3x();
            else if (filter == "hq4x")      config.filter = new FilterHq4x();
            else Log::Write(va("Unknown video filter %s", filter.c_str()));
        }
        else if (lin[0] == "vsync")         gfx.VSync(true);
        else if (lin[0] == "profile")       vcprofile = true;
        else if (lin[0] == "joystick")      config.joy = true,
                                            config.joyIndex = lin[1].empty() ? 0 : atoi(lin[1].c_str());   // default 0, or index, if specified
        else if (lin[0] == "joyx")          config.joyX = atoi(lin[1].c_str());
        else if (lin[0] == "joyy")          config.joyY = atoi(lin[1].c_str());
        else if (lin[0] == "jb1")           config.jb1  = atoi(lin[1].c_str());
        else if (lin[0] == "jb2")           config.jb2  = atoi(lin[1].c_str());
        else if (lin[0] == "jb3")           config.jb3  = atoi(lin[1].c_str());
        else if (lin[0] == "jb4")           config.jb4  = atoi(lin[1].c_str());
        else
            Log::Write(va("Unknown user.cfg command \"%s\"", lin[0].c_str()));
        
        /*
        // No longer used:
        else if (lin[0] == "sound_device");
        else if (lin[0] == "mixrate");
        else if (lin[0] == "safemode");
        else if (lin[0] == "dmabufsize");
        else if (lin[0] == "force8bit");
        else if (lin[0] == "forcemono");
        */
    }
    
    // done parsing config
    vclose(file);
}

void ParseAutoCFG()
{
    VFILE* file = vopen("auto.cfg");
    if (!file) return;

    int size = filesize(file);

    char c[256];
    
    while (vtell(file) < size)
    {
        vgets(c, 255, file);

        console.Exec(c);
    }

    vclose(file);
}

void LoadTransTable()
{ 
    VFILE*	vf;
    u8*   translucency_table;
    
    if (gfx.bpp != 1) return; // why bother?
       
    Log::Writen("Loading 8 bit translucency table");
    
    vf = vopen("TRANS.TBL");
    if (!vf)
    {
        Sys_Error("\ntrans.tbl not found");
    }
    
    translucency_table = new u8[256*256];
    vread(translucency_table, 256*256, vf);

    gfx.InitLucentLUT(translucency_table); // weird, I know. ;)

    delete[] translucency_table;
    vclose(vf);

    Log::Write("...OK");
}

// --tSB moved Conlib_Ver() to conlib.h (that's the only place it's needed anyway :P

// Moved CheckMessages to verge.cpp --andy

void InitSystems()
{
    Log::Init();

    Log::Write("v2.6 startup. Logfile initialized.");
    
    Log::Writen("Initing SDL");
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_JOYSTICK | SDL_INIT_NOPARACHUTE);
    atexit(SDL_Quit);
    SDL_WM_SetCaption("Verge", 0);
    Log::Write("...OK");

    srand(SDL_GetTicks());

    Log::Writen("Sys: Initializing keyboard handler.");
    if (!input.Init())
        Sys_Error("\nError initializing keyboard handler");
    memset(bindarray, 0, 256); // no keys bound yet
    input.ClipMouse(SRect(0, 0, config.xres, config.yres));
    Log::Write("...OK");

    if (config.joy)
    {
        Log::Writen("Initializing joystick");
        input.EnableJoystick(config.joyIndex, config.joyX, config.joyY, config.jb1, config.jb2, config.jb3, config.jb4);
        Log::Write("...OK");
    }

    Log::Writen("Sys: Initializing music system.");
    InitSound();
    Log::Write("...OK");

    Log::Write("Sys: Initializing graphics.");
    if (!gfx.Init(config.xres, config.yres, config.hicolour != 0 ? 16 : 8, !config.window, config.filter))
        Sys_Error("\nError initizlizing graphics");
    if (!gfx.SetPalette(vergepal))
        Sys_Error("\nError setting the palette");

    LoadTransTable();

    Log::Write("...OK");

#ifdef WIN32
    {
        SDL_SysWMinfo info;
        SDL_VERSION(&info.version);
        HWND hWnd = SDL_GetWMInfo(&info) ? info.window : 0;
        if (hWnd)
            SetClassLong(hWnd, GCL_HICON, (long)LoadIcon(GetModuleHandle(0), "AppIcon"));
    }
#endif

    Log::Writen("Sys: Initializing timer. Set 100hz.");
    if (!InitTimer())
        Sys_Error("\nError initing timer");
    Log::Write("...OK");

    ParseAutoCFG();

    int slot = font.Load("system.fnt");

    if (font[slot].IsVacant())
        Sys_Error("Unable to load system.fnt into slot %i", slot);
}

int main(int argc, char* args[])
{
    if (argc > 1)
        startmap = args[1];
    else
    {
        printf("VERGE v."VERSION" build "__DATE__" at "__TIME__". \n");
        printf("Copyright (C)1998 vecna \n");
    }

    // ---Directly from the DOS version -- used to be in verge.cpp but it fits here better. --tSB
    InitializeDefaults();
    ParseStartupFiles();

    InitSystems();

    return VMain();
}
